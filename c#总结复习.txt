练习2：
写一个Ticket类，有一个距离属性（本属性只读，在构造方法中赋值），不能为负数，有一个价格
属性，价格属性只读，并且根据距离distance计算价格Price（1元/公里）
0-100公里       票价不打折
101-200公里   总额打9.5折
201-300公里   总额达9折
300公里以上    总额打8折
有一个方法，可以显示这张票的信息90公里 90块钱
测试上面的类
已完成************************************************************************************************

类有字段，属性，方法，构造函数
字段：存储数据
属性：保护字段，对字段的取值和设值及进行限定
方法：描述对象的行为

构造函数：
1，初始化对象（给对象的每个属性依次的赋值）
2，构造函数的名称跟类一样

this：
1，当前类的对象，用this防止局部变量影响，加上this就是属性了，不是变量
2，调用当前类的构造函数：this（，，）

构造函数：1，没有返回值，连void也没有
   2，构造函数的名称跟类名一样


new：1，在内存中开辟一块空间，
2，在开辟的创建对象
3，调用对象的构造函数

在get中我们进行判断的是字段
在set判断的是value
也可以在构造函数中进行判断
i静态方法需要用类名进行调用
静态类中调用的字段必须是静态的
在静态函数中只能够访问静态成员
静态类不能创建对象

string看可以看作是cahr的只读数组。char c=s【1】；。例子遍历输出stirng中的每个元素
c#中字符串有一个重要的特性，不可变性，字符串一旦声明就不再可以改变。所以只能通过
索引来读取指定位置的char，不能对指定位置的char进行修改
如果是要对char进行修改，那么必须创建一个新的字符串，用s.ToCharArray()方法得到字符串的
char数组，对数组进行修改后，再调用new string（char【】）这个构造函数（暂时不用系研究）
来创建char数组的字符串。一旦字符串被创建，那么char数组的修改也不会造成字符串的拜年话，
例子：将字符串中的s转化为a

练习一：随机输入你心中想得到的一个名字，然后输出它的字符串长度，length：可以得到字符串的长度
string name=“lisa”；
console。writeline（name.length）；
console.readkey();
练习二：两个学员输入各自最喜欢的课程名称，判断是否一致，如果相等，则输出你们两喜欢相同的课程。
如果不相同，则输出你们两喜欢不相同的课程
上题中两位同学输入c#和C#代表同一门课，怎么办

字符串的连续+两边只要有一个是字符串类型，另一个也会被自动转换成字符串类型
一切类型都可以调用，tostring（）方法转换成字符串类型

练习：从日期字符串（2008-08-08）中分析处年，月，日：2008年08月08日。
让用户输入一个日期格式如2008-01-02，你输出你输入的日期为2008年1月2日
使用的是split（chen，stringsplitoption.removeemptyentries）;后面是枚举的方法进行删除掉null值

stringbuilder和string的区别？
答：string在进行运算时（如赋值，拼接）会产生一个新的实例，而stringbuilder则不会。
所以子啊大量字符串拼接或频繁对某一字符串进行操作的时候最好使用stringbuilder，不要
使用string
如果操作一个不断增长的字符串，尽量不用string类改用
stringbuilder类。两个类的工作原理不同string类是一种传统的修改字符串的方式
他确实可以完成把一个字符串添加到另一个字符串上的工作没错，但是在net框架
下，这个操作实在是划不来，因为系统先是把两个字符串写入内存，接着删除原来
的string对象，然后创建一个string对象，并读取内存中的数据赋给该对象，这一来二去
耗了不少的时间，而使用system text命名空间下面的stringbuilder类就不是这样了，它
提供append方法，能够在已有对象的原地进行字符串的修改，简单而且直接，当然
一般情况下觉察不到这两者的区别，但如果你要对某个字符串进行大量的添加操作，
那么stringbuilder类所耗费的时间和string类不是一个数量级的

课上练习1：接受用户输入的字符串，将其中的额字符以与输入相反的顺序输出。“abc”-》“cba”
课上练习2：接受用户输入的一句英文，将其中的单词以反序输出。“hallo wrold”-》“world hallo”
课上练习3：从email中提取中用户名和域名：abc@163.com
课上练习4：文本文件中储存了多个文章标题，作者，标题和作者之间用若干空格，数量不定）隔开，每行
一个，标题有的长有的短，输出到控制台的时候最多标题长度10，如果超过10，则截取长度8的子串并且
最后添加“。。。。。。”，加上一个竖线后输出作者的名字

找出所有的e
让用户输入一句话，判断驻华中有没有邪恶，如果有邪恶替换成这种形式然后输出，如：老牛很邪恶，输出后
变成老牛很**
*******
把（诸葛亮，鸟叔，卡卡西，卡哇伊）之间插入|
****
总结字符串常用的方法

2，继承
写一个reporter类和一个programmer类，Driver类，他们都有一个打招呼的方法，
不同的是reporter打招呼是说“大家好，我叫XX，我的爱好是XXX”programmer的打招呼的方法是说
"大家好，我叫xx，我今年xx岁了，我已经工作xx年了"
摄影家类photographer

字符串
1，字符串的不可变性
2，字符串的一坨方法
split,substring,toupper,tolower,trim,trimend,trimstart,contains,replace,indexof,lastindexof
,startswith,endswith,string.join,string.isNullorEmpty(),tocharArrray,new string(char[]chs)
继承：解决类中的代码冗余
属性 方法 构造函数  子类默认调用父类无参数的构造函数
子类不继成父类的私有字段
this：调用自己的构造函数
base：调用父类的构造函数
new：
其实里氏转换这里面，我遇到了一个问题就是，转换了父类与子类
那么父类继承中的无参构造函数的关系在哪里是不是以构造函数为核心围绕这个问题而进行转变的
而且转变了有什么用
练习一：创建一个集合，里面添加一些数字，求平均值与和
练习二：写一个长度为10的集合，要求在里面随机地存放是个数字（0-9）
但是要求所有的数字不重复
Arraylist方法：
判断是否包含：contains（）
sort等可以处理排序功能（甚至还有max，min，avg等）
获得长度使用count属性
int indexof（object args）
next（）
产生一个整数范围内的随机数，next（num）
产生一个小于num的非负整数，就是0到num-1这些数字
next（minnum，maxnum）
产生一个在minnum到maxnum-1之间的数字，两端取得到


里氏转换：
1，子类可以赋值给父类
2，如果父类中装的是子类，那么可以讲这个父类强制转换为子类对象
集合：
1，arraylist：
1），add       
2），addrange
3），remove
4），removeat
5），removerange
6），insert
7），insertrange
8），clear
9），reverse
10），sort
2，hashtable根据键找值
path类找操作路径的
file类create ，delete，move，copy

//将一个数组中的奇数放到一个集合中，再将偶数放到另一个集合中
list泛型里面

//最终将两个集合合并为一个集合，并且奇数显示再左边，偶数显示在右边

//提示用户输入一个字符串，通过foreach循环将用户输入的字符串
赋值给一个字符数组

//统计welcome to China中每个字符出现的次数不考虑大小写

练习一：创建多个类的方法并输出来，使用多态的虚函数，再通过for循环遍历输出
已完成
练习二：使用多态求矩形的面积和周长以及圆形的面积和周长
已完成，其中学习会c#中保留几位小数可以使用c.tostring("#0.00")
这样子可以保留几位小数
和如何给一个值赋值需要的是
convert.toint32(console.readline())进行转换成你想要的数据

提示：创键属性的快捷键就是ctrl+R+E
1，抽象成员必须标记为abstract，并且不能有任何实现
2，抽象成员必须在抽象类中
3，抽象类不能实例化
4，子类继承抽象类后，必须把父类中的所有抽象成员都重写
（除非子类也是一个抽象类，则可以不重写）
5，抽象成员的访问修饰符不能是private
6，在抽像类中可以包含实例成员。
并且抽象类的实例成员可以不被子类实现
7，抽象类是由构造函数的，虽然不能被实例化
8，如果父类的抽象方法中有参数，那么，继承这个抽象父类在重写父类的方法的时候必须传入对应的参数
ctrl+shift+f10
如果抽象父类的抽象方法中有返回值，那么子类在重写在这个抽象方法的时候，也必须要传入返回值
9，如果父类中的方法有默认的实现，并且父类需要被实例化，这时可以考虑父类定义一个普通类，用虚方法来实现
如果父类中的方法没有默认实现，父类也不需要被实例化，则可以将该类定义为抽象类

封装encapsulation
隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读取和修改的访问级别
封装途径 
封装就是将抽象得到的数据和行为（或者功能）相结合，形成一个有机的整体，也就是
将数据与操作数据的源代码进行有机的结合，形成所谓的类，其中数据和函数都是类的
成员，封装的目的是为了增强安全性和简化编程，使用者不必了解具体的实现细节，而
只是要通过外部接口，以特定的访问权来使用类的成员、
封装在网络编程里面的意思，当应用程序用tcp传送数据时，数据被送入协议线中，然后
逐个通过每一层直到被当作一串比特流送入网络，其中每一层对收到的数据都要增加一些
首部
list<T>这个比arraylist好在不用拆装箱
dictionary<tkey,tvalue>
file stream可以断流断流的操作大文件
streamreader和streamwriter
file只能操作小文件
拆装箱：不管是拆装箱都会影响代码运行时间
多态：虚方法     抽象类：父类没得实例化    接口

接口是一种规范
只要一个类继承了一个接口，这个类就必须实现这个接口中的所有的成员

为了多态，接口不能被实例化
也就是说，接口不能别new（不能创建对象）

接口中的成员不能加“访问修饰符”，接口中的成员访问修饰符public，不能修改
（默认为public）接口中的成员不能有任何实现（“光说不做”，知识定义了一组来实现的成员）

接口中只能有方法，自动属性（因为没有方法体），索引器，事件，不能有“字段”和构造函数

接口与接口之间可以继承，并且可以多继承

接口并不能去继承一个类，而类可以继承接口（接口只能继承于接口，而类既可以继承接口，也可以继承类）

实现接口的子类必须是实现该接口的全部成员

一个类可以同时继承一个类并实现多个接口，如果一个子类同时继承了父类A，并且实现接口IA，那么语法上A必须写在IA的前面

class MyClass：A，IA{}因为类是单继承的

显示实现接口的目的，解决方法的重名问题
什么时候显示的去实现接口
当继承的接口中的方法和参数一摸一样的时候，要使用显示的实现接口

当一个抽象类实现接口的时候，需要子类去实现接口

